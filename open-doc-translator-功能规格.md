### **软件设计与功能规格说明文档**

### **1. 引言**

#### **1.1. 目的**

本文档旨在为“自动化 Git 文档翻译工具”open-doc-translator提供一份全面的设计和功能规格说明。它将作为开发团队、测试团队和项目管理者的核心参考依据，确保对产品的功能、行为和技术实现有一致的理解。

#### **1.2. 范围**

本工具的核心功能是：

* 管理多个基于 Git 的翻译项目。
* 自动化地追踪上游（源）仓库的文件变更。
* 利用大语言模型（LLM）API 进行批量翻译。
* 提供一个集成的 GUI，用于状态监控、版本控制和人工校对。

**范围之外**:

* 本工具**不是**一个通用的 Git 客户端。其 Git 功能仅限于支持翻译工作流所需的基本操作（fetch, checkout, commit, push）。
* 本工具**不负责**项目的初始 Git 设置（如 `fork`, `clone`, `remote add`）。用户需预先完成这些操作。
* 本工具**不提供** LLM 服务，仅作为客户端与用户自行配置的 LLM API 进行交互。

#### **1.3. 目标受众**

* **软件工程师**: 用于理解架构、技术栈和实现细节。
* **QA 工程师**: 用于设计测试用例和验证功能完整性。
* **产品经理**: 用于确认产品功能符合需求。
* **技术文档翻译者/社区贡献者**: 作为最终用户，理解工具的工作原理和使用方法。

#### **1.4. 定义与缩略语**

* **GUI**: Graphical User Interface，图形用户界面。
* **LLM**: Large Language Model，大语言模型。
* **Upstream**: 指向原始项目（如 LangChain 官方）的 Git 远程仓库。
* **Origin**: 指向用户自己 Fork 的 Git 远程仓库。
* **工作分支 (Working Branch)**: 用户在本地进行翻译工作的分支，如 `translation-zh`。
* **状态文件**: 即 `{branch}-translation_state.json`，用于记录翻译状态。
* **Blob Hash**: Git 中用于唯一标识文件内容版本的哈希值。

---

### **2. 系统概述**

#### **2.1. 核心设计理念**

本工具的设计理念是**“约定优于配置”**和**“与 Git 深度集成”**。我们不重新发明轮子，而是将健壮的 Git 工作流封装在一个直观的 GUI 中。通过 `source_hash` 追踪文件状态，确保了翻译同步的精确性和可靠性，避免了基于文件名或修改时间的不可靠追踪方式。

#### **2.2. 高层架构**

系统由以下几个松耦合的模块组成：

* **GUI 层 (Frontend)**: 使用现代桌面应用框架（如 Electron/Tauri）构建，负责所有用户交互。
* **Git 包装器 (Git Wrapper)**: 一个在后台执行 Git 命令并解析其输出的模块。所有与 Git 的交互都通过此模块进行，保证了命令的统一和安全。
* **状态管理器 (State Manager)**: 负责读取、解析、更新和写入状态文件 (`translation_state.json`)。
* **LLM 连接器 (LLM Connector)**: 负责根据用户配置，构建并发送 API 请求到 LLM 服务，并处理返回结果。
* **文件系统 I/O**: 负责读写本地文件，包括翻译稿、配置文件等。

#### **2.3. 前提条件：项目手动设置**

在工具中添加任何项目之前，用户必须在命令行中完成以下一次性设置：

1. **Fork 仓库**: 在 GitHub 等平台，Fork 目标上游项目到自己的账户下。
2. **克隆本地**: `git clone <你的 Fork 仓库 URL>`
3. **进入目录**: `cd <项目目录>`
4. **设置上游**: `git remote add upstream <上游官方仓库 URL>`
5. **创建工作分支**: `git checkout -b translation-zh` (或自定义名称)

---

### **3. 核心概念与数据结构**

#### **3.1. 全局配置文件 (`config.json`)**

* **位置**: `~/.autotranslator/config.json` (在用户主目录下的隐藏文件夹中)。

* **用途**: 存储所有非项目特定的全局设置。

* **结构**:
  
  ```json
  {
    "projects": [
      {
        "id": "proj-uuid-1",
        "name": "LangChain Docs",
        "path": "/Users/user/dev/langchain",
        "remotes": {
          "origin": "git@github.com:user/langchain.git",
          "upstream": "https://github.com/langchain-ai/langchain.git"
        },
        "rules": {
          "include_dirs": "docs",
          "file_exts": "md,mdx",
          "special_files": "README.md,CHANGELOG.md"
        },
        "prompt":""
      }
    ],
    "llm_settings": {
      "api_key": "sk-...",
      "base_url": "https://api.openai.com/v1",
      "model": "gpt-4-turbo",
      "temperature": 0.7,
      "concurrency": 5
    },
    "prompt_templates": [
      {
        "name": "Default Tech Doc",
        "content": "Translate the following Markdown document into Chinese. Keep the original formatting, code blocks, and links intact. Pay attention to technical terms."
      }
    ]
  }
  ```

#### **3.2. 状态管理文件 (`{branch}-translation_state.json`)**

* **位置**: 项目根目录下，文件名与当前工作分支绑定。

* **用途**: 作为项目翻译进度的“单一事实来源 (Single Source of Truth)”。

* **结构**:
  
  ```json
  {
    "docs/getting_started.md": {
      "source_hash": "a1b2c3d4e5f6...", // 上游 main 分支中此文件的 Blob Hash
      "last_translated_at": "2023-10-27T10:00:00Z",
      "translator_version": "1.0"
    },
    "docs/core_docs/expression_language/index.md": {
      "source_hash": "f6e5d4c3b2a1...",
      "last_translated_at": "2023-10-26T18:30:00Z",
      "translator_version": "1.0"
    }
  }
  ```

#### **3.3. 翻译状态判定逻辑**

对于上游分支的每一个目标文件，系统通过以下逻辑确定其状态：

1. **获取上游 Hash**: `current_hash = git rev-parse {upstream_branch}:{file_path}`
2. **获取记录 Hash**: `recorded_hash = state_file[file_path]?.source_hash`
3. **判定**:
   * **未翻译 (Untranslated)**: `recorded_hash` 不存在。
   * **已过时 (Outdated)**: `recorded_hash` 存在，但 `current_hash !== recorded_hash`。
   * **已翻译 (Up-to-date)**: `recorded_hash` 存在，且 `current_hash === recorded_hash`。

---

### **4. 详细功能规格**

#### **4.1. 主窗口布局**

主窗口采用经典的三栏布局：

* **顶部**: 全局工具栏，用于设置工作上下文。
* **左侧**: 导航与管理面板，包含文件树、Git 组件和设置。
* **右侧**: 主工作区，用于文件内容的对比和编辑。

#### **4.2. 顶部工具栏 (Global Control Bar)**

| 控件/功能                          | 描述                              | 技术实现/后台逻辑                                                                                                                                                                                                 |
|:------------------------------ |:------------------------------- |:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **项目 (Project) 下拉框**           | 列出所有已添加的项目，用于切换当前工作项目。          | 读取全局 `config.json` 中的 `projects` 数组填充列表。选择后，更新应用的当前工作目录和项目配置。                                                                                                                                             |
| **添加项目 (Add Project) 按钮**      | 弹窗引导用户注册一个**已手动设置好**的本地 Git 仓库。 | 1. 打开系统文件选择器。<br>2. 验证所选目录为 Git 仓库。<br>3. 自动执行 `git remote get-url origin` 和 `git remote get-url upstream`。<br>4. 将项目信息写入全局 `config.json`。                                                                |
| **上游分支 (Upstream Branch) 下拉框** | 选择作为翻译源头的上游分支。                  | 执行 `git branch -r \| grep 'upstream/'` 解析并填充列表。所选值用于后续所有 Git 操作。                                                                                                                                          |
| **刷新上游分支 (Refresh) 按钮**        | 拉取上游最新变更，并刷新文件树状态。              | 1. 显示加载指示器。<br>2. 执行 `git fetch upstream`。<br>3. 触发完整的**状态判定逻辑**（见 3.3）。<br>4. 更新文件树 UI。<br>5. 隐藏加载指示器。                                                                                                   |
| **工作分支 (Working Branch) 下拉框**  | 切换存放翻译稿的本地分支。                   | 1. 执行 `git branch` 填充列表。<br>2. **切换前**: 执行 `git status --porcelain`，若有输出则弹窗警告并**中止切换**。<br>3. **执行切换**: `git checkout <selected_branch>`。<br>4. **切换后**: 自动加载新的 `{branch}-translation_state.json` 并刷新文件树。 |

#### **4.3. 左侧面板 (Side Panel)**

这是一个带标签页的面板，包含“文件”、“Git”和“设置”。

##### **4.3.1. 文件树 (File Tree) 组件**

| 控件/功能                         | 描述                           | 技术实现/后台逻辑                                                                                                                                                               |
|:----------------------------- |:---------------------------- |:----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **状态筛选器**                     | `全部 / 未翻译 / 已过时 / 已翻译` 单选按钮。 | 纯前端 UI 过滤器，根据内存中缓存的文件状态进行显示/隐藏。                                                                                                                                         |
| **文件筛选器**                     | 文本框，用于模糊搜索文件名和路径。            | 纯前端 UI 过滤器，实时过滤树节点。                                                                                                                                                     |
| **文件大小筛选器**                   | 最小/最大大小，单位kb                 | 纯前端 UI 过滤器，用于筛选出合适的文件。                                                                                                                                                  |
| **批量翻译 (Batch Translate) 按钮** | 点击后弹出对话框，有筛选/全选，文件树，选好后点击翻译。 | 1. 收集任务队列。<br>2. 根据 `llm_settings.concurrency` 创建任务池。<br>3. 对每个文件，执行：`git show` 获取原文 -> 调用 LLM API -> 写入译文 -> 更新状态文件。<br/>（注意翻译的时候要根据文件名来翻译，有普通的翻译，如果是ipynb需要进行特殊的翻译逻辑） |
| **树形文件列表**                    | 以目录结构展示上游文件，并用颜色标记状态。        | 根据**状态判定逻辑**（见 3.3）的结果进行渲染。文件节点颜色：灰色（未翻译）、黄色（已过时）、绿色（已翻译）。                                                                                                              |

##### **4.3.2. Git 组件**

| 控件/功能            | 描述                   | 技术实现/后台逻辑                                   |
|:---------------- |:-------------------- |:------------------------------------------- |
| **变更列表**         | 显示 `git status` 的结果。 | 执行 `git status --porcelain`，解析输出生成可交互的文件列表。 |
| **提交信息框 & 提交按钮** | 暂存并提交所有变更。           | `git add .` -> `git commit -m "..."`。       |
| **推送按钮**         | 将本地提交推送到 `origin`。   | `git push origin <current_working_branch>`。 |

##### **4.3.3. 设置 (Settings) 组件**

| 控件/功能             | 描述                  | 技术实现/后台逻辑                                          |
|:----------------- |:------------------- |:-------------------------------------------------- |
| **LLM 服务配置 (全局)** | 配置 API Key、模型、并发数等。 | 所有表单字段双向绑定到全局 `config.json` 的 `llm_settings` 对象。   |
| **翻译提示词 (全局)**    | 管理和选择翻译提示词模板。       | 增删改查操作作用于全局 `config.json` 的 `prompt_templates` 数组。 |
| **项目特定配置**        | 配置当前项目的监听目录、文件类型等。  | 表单字段双向绑定到当前项目在 `config.json` 中的 `rules` 对象。        |

#### **4.4. 右侧工作区 (Workspace)**

| 控件/功能                      | 描述                  | 技术实现/后台逻辑                                                                                        |
|:-------------------------- |:------------------- |:------------------------------------------------------------------------------------------------ |
| **顶部信息栏**                  | 显示当前文件的绝对路径和状态。     | 从文件树选定节点的数据中读取。                                                                                  |
| **重新翻译 (Re-translate) 按钮** | 对当前单个文件强制执行翻译。      | 对当前文件触发**单文件翻译流程**（同批量翻译中的单个任务）。                                                                 |
| **保存 (Save) 按钮**           | 保存用户在译文编辑器中的手动修改。   | 将右侧编辑器内容写入本地文件系统。**注意**: 此操作不更新 `source_hash`，仅为人工校对保存。                                          |
| **双栏对比视图**                 | 左侧原文（只读），右侧译文（可编辑）。 | **左侧**: `git show {upstream_branch}:{file_path}` 获取内容。<br>**右侧**: `fs.readFile` 从本地工作分支读取译文文件内容。 |

---

### **5. 用户工作流与用例**

#### **5.1. 用例1：首次添加并配置项目**

1. **用户 (线下)**: 完成手动 Git 设置（Fork, Clone, Upstream, Branch）。
2. **用户 (工具)**: 点击“添加项目”按钮。
3. **系统**: 弹出文件选择器。
4. **用户**: 选择本地项目根目录。
   
   
5. 
6. **系统**: 将项目信息存入全局配置，并在“项目”下拉框中显示新项目。
7. **用户**: 切换到新项目，进入“设置”页面，配置项目特定的监听规则。

#### **5.2. 用例2：日常同步翻译**

1. **用户**: 打开工具，选择要同步的项目。
2. **用户**: 点击“刷新上游分支”按钮。
3. **系统**: 执行 `git fetch upstream`，然后重新计算所有文件的状态，文件树的颜色发生变化（部分文件可能从绿色变为黄色）。
4. **用户**: 查看文件树，确认“已过时”和“未翻译”的文件范围。
5. **用户**: 点击“批量翻译”按钮。
6. **系统**: 弹窗显示将要翻译的文件列表，用户确认后开始后台任务。进度条显示翻译进度。
7. **系统**: 翻译完成后，提示用户。文件树中所有文件变为绿色。
8. **用户**: 切换到“Git”面板，看到被修改的翻译稿和状态文件。
9. **用户**: 输入提交信息（如 "chore: sync translations up to upstream/main"），点击“提交”，然后“推送”。

#### **5.3. 用例3：手动校对与微调**

1. **用户**: 在文件树中点击一个已翻译（绿色）的文件。
2. **系统**: 在右侧工作区加载双栏对比视图。
3. **用户**: 阅读原文和译文，发现译文中某个术语不准确。
4. **用户**: 在右侧的可编辑区域修改译文。
5. **用户**: 点击“保存”按钮。
6. **系统**: 将修改后的内容保存到本地文件。
7. **用户**: 切换到“Git”面板，看到该文件出现在变更列表中，正常提交和推送。

---

### **6. 附录**

#### **6.1. 附录A：示例 `config.json`**

（见上文 3.1 节）

#### **6.2. 附录B：示例 `translation_state.json`**

（见上文 3.2 节）

#### **6.3. 附录C：核心工作流图示**

```mermaid
graph TD
    A[开始处理文件: path/to/file.md] --> B[git rev-parse upstream/main:path/to/file.md];
    B --> C[获取 current_hash];
    C --> D[读取 state.json 文件];
    D --> E{在 state.json 中找到该文件记录?};

    E -- 否 --> F[状态: 未翻译 (灰色)];
    E -- 是 --> G[获取 recorded_hash];
    G --> H{current_hash === recorded_hash?};

    H -- 是 --> I[状态: 已翻译 (绿色)];
    H -- 否 --> J[状态: 已过时 (黄色)];

    F --> K[执行翻译流程];
    J --> K;

    subgraph "翻译流程 (Translation Flow)"
        direction LR
        L[git show upstream/main:path/to/file.md] --> M[获取原文];
        M --> N[调用 LLM API 翻译];
        N --> O[写入/覆盖本地译文文件];
        O --> P[更新 state.json 中该文件的 source_hash];
    end

    K --> Q[流程结束，处理下一个文件];
    I --> Q;
```
